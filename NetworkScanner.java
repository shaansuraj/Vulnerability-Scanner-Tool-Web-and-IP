import java.io.*;
import java.net.*;
import java.util.*;
import java.util.regex.*;

public class NetworkScanner {
    private static final int TIMEOUT = 1000; // Timeout in milliseconds
    private int startPort = 1;
    private int endPort = 65535;

    public void setPortRange(int startPort, int endPort) {
        this.startPort = startPort;
        this.endPort = endPort;
    }

    public List<String> scanHost(String host) {
        List<String> openPorts = new ArrayList<>();
        scanPorts(host, openPorts);
        return openPorts;
    }

    private void scanPorts(String host, List<String> openPorts) {
        for (int port = startPort; port <= endPort; port++) {
            try (Socket socket = new Socket()) {
                socket.connect(new InetSocketAddress(host, port), TIMEOUT);
                String serviceInfo = getServiceInfo(socket, port);
                openPorts.add(host + ":" + port + " is open - " + serviceInfo);
            } catch (IOException ignored) {
                // Port is not open, ignore exception
            }
        }
    }

    private String getServiceInfo(Socket socket, int port) {
        try {
            switch (port) {
                case 80:
                case 443:
                    return getHttpBanner(socket);
                case 21:
                    return getFtpBanner(socket);
                default:
                    return "Unknown service";
            }
        } catch (IOException e) {
            return "Failed to retrieve service info";
        }
    }

    private String getHttpBanner(Socket socket) throws IOException {
        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

        out.println("GET / HTTP/1.1");
        out.println("Host: " + socket.getInetAddress().getHostAddress());
        out.println("Connection: close");
        out.println();

        String line;
        while ((line = in.readLine()) != null) {
            if (line.startsWith("Server:")) {
                return line;
            }
        }
        return "HTTP service, version unknown";
    }

    private String getFtpBanner(Socket socket) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        return in.readLine(); // FTP banner is typically sent immediately upon connection
    }

    public String crawlWebApplication(String url) {
        try {
            URL targetUrl = new URL(url);
            HttpURLConnection connection = (HttpURLConnection) targetUrl.openConnection();
            connection.setRequestMethod("GET");

            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            StringBuilder content = new StringBuilder();
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                content.append(inputLine).append("\n");
            }
            in.close();
            return content.toString();
        } catch (IOException e) {
            return "Failed to crawl web application: " + e.getMessage();
        }
    }

    public List<String> scanWebApplication(String url) {
        List<String> vulnerabilities = new ArrayList<>();
        String webContent = crawlWebApplication(url);

        // Web application content and basic info
        vulnerabilities.add("URL: " + url);
        vulnerabilities.add("Web Content Preview: " + getPreview(webContent));

        // Security checks
        vulnerabilities.addAll(checkSecurityHeaders(url));
        vulnerabilities.addAll(scanForOutdatedLibraries(webContent));
        vulnerabilities.addAll(scanForUnvalidatedRedirects(webContent));
        vulnerabilities.addAll(scanForInsecureDirectObjectReferences(webContent));

        return vulnerabilities;
    }

    private List<String> checkSecurityHeaders(String url) {
        List<String> vulnerabilities = new ArrayList<>();
        try {
            URL targetUrl = new URL(url);
            HttpURLConnection connection = (HttpURLConnection) targetUrl.openConnection();
            connection.setRequestMethod("HEAD");

            Map<String, List<String>> headerFields = connection.getHeaderFields();
            if (!headerFields.containsKey("Content-Security-Policy")) {
                vulnerabilities.add("Missing security header: Content-Security-Policy");
            }
            if (!headerFields.containsKey("X-Frame-Options")) {
                vulnerabilities.add("Missing security header: X-Frame-Options");
            }
            // More header checks can be added here

        } catch (IOException e) {
            vulnerabilities.add("Error checking security headers: " + e.getMessage());
        }
        return vulnerabilities;
    }

    private String getPreview(String content) {
        // Returns a preview of the web content (first 200 characters or full content if shorter)
        return content.length() > 200 ? content.substring(0, 200) + "..." : content;
    }

    private List<String> scanForOutdatedLibraries(String content) {
        List<String> foundVulnerabilities = new ArrayList<>();
        Pattern scriptPattern = Pattern.compile("<script[^>]*src=['\"]([^'\"]+)['\"][^>]*>", Pattern.CASE_INSENSITIVE);
        Matcher scriptMatcher = scriptPattern.matcher(content);

        while (scriptMatcher.find()) {
            String scriptSrc = scriptMatcher.group(1);
            if (scriptSrc.contains("jquery-2.1.1")) {
                foundVulnerabilities.add("Outdated jQuery library detected: jQuery 2.1.1");
            }
            // Check for outdated Bootstrap library
        if (scriptSrc.contains("bootstrap-3.3.7")) {
            foundVulnerabilities.add("Outdated Bootstrap library detected: Bootstrap 3.3.7");
        }

        // Check for outdated React library
        if (scriptSrc.contains("react-15.4.2")) {
            foundVulnerabilities.add("Outdated React library detected: React 15.4.2");
        }

        // Check for outdated Angular library
        if (scriptSrc.contains("angular-1.5.8")) {
            foundVulnerabilities.add("Outdated Angular library detected: Angular 1.5.8");
        }
        if (scriptSrc.contains("vue-2.5.0")) {
            foundVulnerabilities.add("Outdated Vue.js library detected: Vue.js 2.5.0");
        }
        if (scriptSrc.contains("moment-2.20.0")) {
            foundVulnerabilities.add("Outdated Moment.js library detected: Moment.js 2.20.0");
        }
        if (scriptSrc.contains("d3-4.10.0")) {
            foundVulnerabilities.add("Outdated D3.js library detected: D3.js 4.10.0");
        }
            
        }
        return foundVulnerabilities;
    }

    private List<String> scanForUnvalidatedRedirects(String content) {
        List<String> foundVulnerabilities = new ArrayList<>();
        Pattern redirectPattern = Pattern.compile("window\\.location\\.href\\s*=\\s*['\"]([^'\"]+)['\"]", Pattern.CASE_INSENSITIVE);
        Matcher redirectMatcher = redirectPattern.matcher(content);

        while (redirectMatcher.find()) {
            String redirectUrl = redirectMatcher.group(1);
            if (!redirectUrl.startsWith("http")) {
                foundVulnerabilities.add("Potential unvalidated redirect found: " + redirectUrl);
            }
        }
        return foundVulnerabilities;
    }

    private List<String> scanForInsecureDirectObjectReferences(String content) {
        List<String> foundVulnerabilities = new ArrayList<>();
        Pattern idPattern = Pattern.compile("href=['\"]([^'\"]+/\\d+)['\"]", Pattern.CASE_INSENSITIVE);
        Matcher idMatcher = idPattern.matcher(content);

        while (idMatcher.find()) {
            String idUrl = idMatcher.group(1);
            if (idUrl.matches(".*/\\d+$")) {
                foundVulnerabilities.add("Potential insecure direct object reference found: " + idUrl);
            }
        }
        return foundVulnerabilities;
    }
}
